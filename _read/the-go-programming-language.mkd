---
title: The Go Programming Language
---

Chapter 2: Program Structure
============================

### Names

If an entity is declared within a function, it is _local_ to that function. If declared outside a function, however, it is visible in all files of the package to which it belongs. The case of the first letter of a name determines its visibility across package boundaries. If the name begins with an upper-case letter, it is _exported_, which means it is visible and accessible outside of its own package and may be referred to by other parts of the program, as with `Printf` in `fmt` package. Package names themselves are always in lower case.

Generally, the larger the scope of a name, the longer and more meaningful it should be.

Stylistically, Go programmers use "camel case" when forming names by combining words. The letters of acronyms and initialisms like ASCII and HTML are always rendered in the same case.

### Declarations

A _declaration_ names a program entity and specifies some or all of its properties. There are four major kinds of declarations: `var`, `const`, `type` and `func`.

The `package` declaration is followed by any `import` declarations, and then a sequence of _package-level_ declarations of types, variables, constants and functions, in any order.

### Variables

Each variable declaration has the general form

    var name type = expression

Either the type or the `= expression` part may be omitted, but not both. If the type is omitted, it is determined by the initializer expression. If the expression is omitted, the initial value is the _zero value_ of the type, which is `0` for numbers, `false` for booleans, `""` for strings, and `nil` for reference types(slice, pointer, map, channel, function). The zero value of an aggregate type like an array or a struct has the zero value of all of its elements or fields.

The zero-value mechanism ensures that a variable always holds a well-defined value of its type; in Go there's no such thing as an uninitialized value.

Initializers may be literal values or arbitrary expressions. Package-level variables are initialized before `main` begins, and local variables are initialized as their declarations are encountered during function _execution_.

Within a function, an alternate form called a `short variable declaration` may be used to declare and initialize local variables. It takes the form `name := expression`, and the type of `name` is determined by the type of `expression`.

Because of their brevity and flexibility, short variable declarations are used to declare and initialize the majority of local variables. A `var` declaration tends to be reserved for local variables that need an explicit type that differs from that of the initializer expression, or for when the variable will be assigned a value later and its initial value is unimportant.

    i := 100 // an int
    var boiling float64 := 100 // a float64

### Pointers

A _variable_ is a piece of storage containing a value. Variables created by declarations are identified by name, such as `x`, but many variables are only identified by expressions like `x[i]` or `x.f`. _All these expressions read the value of a variable, except when they appear on the left-hand side of an assignment, in which case a new value is assigned to the variable_.

A _pointer_ value is the _address_ of a variable. A pointer is thus the location at which a value is stored. _Not every value has an address, but every variable does_. With a pointer, we can read or update the value of a variable _indirectly_, without using or even knowing the name of a variable, if indeed it has a name.

If a variable is declared `var x int`, the expression `&x` ("address of `x`") yields a pointer to an integer variable, that is, a _value_ of type `*int`, which is pronounced "pointer to int". If this value is called `p`, we say "`p` points to `x`", or equivalently "`p` contains the address of `x`." _The variable to which `p` points is written `*p`_. The expression `*p` yields the value of that variable, an `int`, but since `*p` denotes a variable, it may also appear on the left-hand side of an assignment, in which case the assignment updates the variable.

Each component of a variable of aggregate type--a field of a struct or an element of an array--is also a variable and thus has an address too.

Variables are sometimes described as _addressable values_. _Expressions_ that denote variables are the only expressions to which the _address-of_ operator `&` may be applied.

The zero value for a pointer of any type is `nil`. The test `p != nil` is true if `p` points to a variable. Pointers are comparable; two pointers are equal if and only if they point to the same variable or both are `nil`.

It is perfectly safe for a function to return the address of a _local_ variable. For instance, in the code below, the local variable `v` created by the particular call to `f` will remain in existence even after the call has returned, and the pointer `p` will still refers to it:

    var p = f()
    function f() *int {
        v := i
        return &v
    }

Each call of `f` returns a distinct value:

    fmt.Println(f() == f()) // "false"

### Lifetime of Variables

The lifetime of a variable is the interval of time during which it exists as the program executes. The lifetime of a package-level variable is the entire execution of the program. By contrast, local variables have dynamic lifetimes: a new instance is created each time the declaration statement is executed, and the variable lives on until it becomes _unreachable_, at which point its storage may be recycled. Function parameters and results are local variables too; they are created each time their enclosing function is called.

How does the garbage collector know that a variable's storage can be reclaimed? The full story is much more detailed that we need here, but the idea is that the package-level variable, and every local variable of each currently active function, can potentially be the start or the root of the path to the variable in question, following pointers and other kinds of references that ultimately lead to the variable. If no such path exists, the variable has become unreachable, so it can no longer affect the rest of the computation.

Because the lifetime of a variable is determined only by whether or not it is reachable, a local variable may outlive a single iteration of the enclosing loop. It may continue to exist even after its enclosing function has returned.

### Assignability

An assignment, explicit or implicit, is always legal if the left-hand side(the variable) and the right-hand side(the value) have the same type. More generally, the assignment is legal only if the value is _assignable_ to the type of the variable.

The rule for _assignability_ has cases for various types, so we will explain the relevant case as we introduce each new type. For the types we've discussed so far, the rules are simple: the types must exactly match, and nil may be assigned to any variable of interface or reference type.

Whether two values may be compared with `==` or `!=` is related to assignability: in any comparison, the first operand must be assignable to the type of the second operand, or vice versa.

### Type Declarations

A `type` declaration defines a new _named type_ that has the same _underlying type_ as an existing type. The named type provides a way to separate different and perhaps incompatible uses of the underlying type so that they can't be mixed unintentionally.

    type name underlying-type

Different name types with the same underlying type are not the same type, so they cannot be compared or combined with arithmetic expressions. 

For every type `T`, there is a corresponding operation `T(x)` that converts the value `x` to type `T`. A conversion from one type to another is allowed if both have the same underlying type, or if both are _unnamed pointer types(?)_ that point to variables of the same underlying type; these conversions change the type but not the representation of the value. 

Conversions are also allowed between numeric types, and between string and some slice types. _These conversions may change the representation of the value_. For instance, converting a floating-point number to an integer discard any fractional part, and converting a string to a `[]byte` slice allocates a copy of the string data.

The underlying type of a named type determines its structure and representation, and also the set of intrinsic operations it supports, which are the same as if the underlying type had been used directly.

Comparison operator like `==` and `<` can also be used to compare a value of a named type to another of the same type, or to a _value of the underlying type(?)_. But two values of different named types cannot be compared directly:

    type Celcius int
    var a int = 3
    var b Celcius = 3
    b = a // "cannot use a (type int) as type Celcius in assignment"
    fmt.Println(b == a) // "invalid operation: b == a (mismatched types Celcius and int)"
    fmt.Println(b == 3) // "true"


Chapter 3: Basic Data Types
===========================

Go's types fall into four categories: _basic types_, _aggregate types_, _reference types_, and _interface types_. Basic types include numbers, strings, and booleans. Aggregate types--arrays and structs--form more complicated data types by combining values of several simpler ones. Reference types are a diverse group that includes pointers, slice, maps, functions, and channels, but what they have in common is that they are refer to program variables and state _indirectly_, so that the effect of a operation applied to one reference is observed by all copies of that reference.

### Integers

There are two types called `int` and `uint` that are the natural or the most efficient size for signed and unsigned integers on a particular platform; `int` is by far the most widely used numeric type. Both these types have the same size, either 32 or 64 bits, but one must not make assumptions about which; different compilers may make different choices even on identical hardware.

The type `rune` is synonym for `int32` and conventionally indicates that a value is a Unicode code point. The two names may be used interchangeably. Similarly, the type `byte` is a synonym for `uint8`, and emphasizes that the value is a piece of raw data rather a small numeric quantity.

Regardless of their size, `int`, `uint`, and `uintptr` are different types from their explicitly sized siblings. Thus `int` is not the same type as `int32`, even if the natural size of `int` is 32 bits, and an explicit conversion is required to use and `int` value where an `int32` is needed, and vice versa.

Go's binary operators for arithmetic, logic, and comparison are listed here in the order of decreasing precedence:

    * / % << >> & &^
    + - | ^
    == != < <= > >=
    &&
    ||

There are only five levels of precedence for binary operators. Operators at the same level associate to the left.

The integer arithmetic operators `+`, `-`, `*`, `/` may be applied to integers, floating-point, and complex numbers, but the remainder operator `%` applies only to integers. The behavior of `%` for negative numbers varies across programming languages. In Go, the sign of the remainder is always the same as the sign of the dividend, so `-5%-3` and `-5/3` are both `-2`. The behavior of `/` depends on whether its operands are integers, so `5.0/4.0` is `1.25`, but `5/4` is `1` because integer division truncates the result toward zero.

If the result of an arithmetic operation, whether signed or unsigned, has more bits than can be represented in the result type, it is said to _overflow_. The high-order bits that do not fit are silently discarded. If the original number is a signed type, the result could be negative if the leftmost bit is a `1`, as in the `int8` example here:

    var u uint8 = 255
    fmt.Println(u, u+1) // "255, 0"

    var i int8 = 127
    fmt.Println(u, u+1) // "127 -128"

In general, an explicit conversion is required to convert a value from one type to another, and binary operators for arithmetic and logic (except shifts) must have operands of the same type. Although this occasionally results in longer expressions, it also eliminates a whole class of problems and makes programs easier to understand.

### Booleans

A value of type `bool`, or _boolean_, has only two possible values, `true` and `false`. The conditions in `if` and `for` statements are booleans, and comparison operators like `==` and `<` produce a boolean result.

There is no implicit conversion from a boolean value to a numeric value like 0 and 1, or vice versa.

### Strings

A string is an immutable sequence of bytes. The built-in `len` function return the number of bytes (not runes) in a string, and the _index_ operation `s[i]` retrieves the `i`-th byte of string `s`, where 0 <= i < len(s).

The `i`-th byte of a string is not necessarily the `i`-th _character_ of a string, because the UTF-8 encoding of a non-ASCII code point require two or more bytes.

String values are immutable: the byte sequence contained in a string value can never be changed, though of course we can assign a new value to a string _variable_.

Immutability means that it is safe for two copies of a string to share the same underlying memory, making it cheap to copy strings of any length. Similarly, a string `s` and a substring `s[7:]` may safely share the same data, so the substring operation is also cheap. No new memory is allocated in either case.

### String Literals

A string value can be written as a _string literal_, a sequence of bytes enclosed in double quotes.

Because Go source files are always encoded in UTF-8 and go text strings are conventionally interpreted as UTF-8, we can include Unicode code points in string literals.

Within a double-quoted string literal, _escape sequences_ that begin with a backslash `\` can be used to insert arbitrary byte values into the string.

Arbitrary bytes can also be include in literal strings using hexadecimal and octal escapes.

A _raw string literal_ is written ``...``, using backquotes instead of double quotes. Within a raw string literal, no escape sequences are processed. Raw string literals are convenient ways to write regular expressions, which tend to have lots of backslashes.

### Unicode

Unicode collects all of the characters in all of the world's writing systems, and assigns each one a standard number called _Unicode code point_, in Go terminology, a _rune_.

The natural data type to hold a single rune is `int32`, and that's what go uses; it has the synonym `rune` for precisely this purpose.

### UTF-8

We could represent a sequence of runes as a sequence of `int32` values. In this representation, which is called UTF-32 or UCS-4, the encoding of each Unicode code point has the same size, 32 bits. This is simple and uniform, but it uses much more space than necessary since most computer-readable text is in ASCII, which requires only 8 bits or 1 byte per character. All the characters in widespread use still number fewer that 65536, which would fit in 16 bits.

UTF-8 is a variable-length encoding of Unicode code points as bytes. It uses between 1 and 4 bytes to represent each rune, but only 1 byte for ASCII characters, and only 2 to 3 bytes for most runes in common use. The high-order bits of the first byte of the encoding for a rune indicate how many bytes follow. A high-order `0` indicates 7-bits ASCII, where each runes takes only 1 byte, so it identical to conventional ASCII. A high-order `110` indicates that the rune takes 2 bytes; the second byte begins with `10`. Larger runes have analogous encodings.

A variable-length encoding precludes direct indexing to access the `n`-th character of a string, but UTF-8 has many desirable properties to compensate. The encoding is compact, compatible with ASCII, and _self-synchronizing_.

Unicode escape in Go string literals allow us to specify them by their numeric code point value. There are two forms, `\uhhhh` for a 16-bit value and `\Uhhhhhhhh` for a 32-bit value, where each `h` is a hexadecimal digit; the need for the 32-bit form arises very infrequently.

A rune whose value is less that 256 may be written with a single hexadecimal escape, such as `\x41` for `'A'`, but for higher values, a `\u` or `\U` escape must be used. Consequently, `\xe4\xb8\x96` is not a legal rune literal, even though those three bytes are a valid UTF-8 encoding of a single code point.

Thanks to the nice properties of UTF-8, many string operations don't require decoding. We can test whether one string contains another as a prefix, or as a suffix, or as a substring using the same logic for UTF-8-encoded text as for raw bytes. This is not true for other encodings.

On the other hand, if we really care about the individual Unicode characters, we need a UTF-8 decoder. Go's `range` loop, when applied to a string, performing UTF-8 decoding implicitly.

UTF-8 is exceptionally as an interchange format but within a program runes may be more convenient because they are of uniform size and are thus easily indexed in arrays and slices.

A `[]rune` conversion applied to a UTF-8-encoded string return the sequence of Unicode code points that the string encodes. If a slice of runes is converted to a string, it produces the concatenation of the UTF-8 encodings of each rune.

### Strings and Byte Slices

A strings contains an array of bytes that, once created, is immutable. By contrast, the elements of a byte slice can be modified freely.

Strings can be converted to byte slices and back again:

    s := "abc"
    b := []byte(s)
    s2 := string(b)

Conceptually, the `[]byte(s)` conversion allocates a new byte array holding a copy of the bytes of `s`, and yields a slice that references the entirety of that array. The conversion from byte slice back to string with `string(b)` also makes a copy, to ensure the immutability of the resulting string `s2`.

To avoid conversions and unnecessary memory allocation, many of the utility functions in the `bytes` packages directly parallel their counterparts in the `string` package.

The `bytes` package provides the `Buffer` type for efficient manipulation of byte slices. A `Buffer` starts out empty but grows as data of types like `string`, `byte` and `byte[]` are written to it. A `bytes.Buffer` variable requires no initialization because its zero value is usable.

When appending the UTF-8 encoding of a arbitrary rune to a `bytes.Buffer`, it's best to use `bytes.Buffer`'s `WriteRune` method, but `WriteByte` is fine for ASCII characters such as `[` and `]`.


### Constants

Constants are expressions whose value is known to compiler and whose evaluation is guaranteed to occur at compile time, not at run time. The underlying type of every constant is a basic type: boolean, string, or number.

The results of all arithmetic, logic, and comparison operations applied to constant operands are themselves constants, as are the results of conversions and calls to certain built-in functions such as `len`, `cap`, `real`, `imag`, `complex`, and `unsafe.Sizeof`.

A constant declaration may specify a type as well as a value, but in the absence of an explicit type, the type is inferred from the expression on the right-hand side.

Chapter 4: Composite Types
==========================

In this chapter, we'll take a look at _composite_ types, the molecules created by combining the basic types in various ways. We'll talk about four such types--arrays, slices, maps, and structs.

Arrays and structs are _aggregate_ types; their values are concatenations of other values in memory. Arrays are homogenous--their elements all have the same type--whereas structs are heterogenous. Both arrays and structs are fixed size. In contrast, slices and maps are dynamic data structures that grow as values are added.

### Arrays

An array is a fixed-length sequence of zero or more elements of a particular type. Because of their fixed length, arrays are rarely used directly in Go. Slices, which can grow and shrink, are much more versatile.

By default, the elements of a new array variable are initially set to zero value for the element type, which is `0` for numbers. We can use an _array literal_ to initialize an array with a list of values.

    var q [3]int = [3]int{1, 2, 3}
    var r [3]int = [3]int{1, 2}

In an array literal, if an ellipsis "`...`" appears in place of the length, the array length is determined by the number of initializers. The definition of `q` can be simplified to:

    q := [...]int{1, 2, 3}

The size of an array is part of its type, so `[3]int` and `[4]int` are different types. The size must be a constant expression, that is, an expression whose value can be computed as the program is being compiled.

If an array's elements are _comparable_ then the array type is comparable too, so we may directly compare two arrays of that type using the `==` operator, which reports whether all corresponding elements are equal. The `!=` operator is its negation.

When a function is called, a copy of each argument value is assigned to the corresponding parameter variable, so the function receives a copy, not the original. Passing large arrays in this way can be inefficient, and any changes that the function makes to array elements affect only the copy, not the original. In this regard, Go treats arrays like any other type, but this behavior is different from languages that implicitly pass arrays _by reference_.

Of course, we can explicitly pass a pointer to an array so that any modifications the function make to array elements will be visible to the caller. This function zeroes the contents of a `[32]byte` array:

    func zero(ptr * [32]byte) {
        *ptr = [32]byte{}
    }

The array literal `[32]byte{}` yields an array of 32 bytes. Each element of the array has the zero value for `byte`, which is `0`. 

Using a pointer to an array is efficient and allow the called function to mutate the caller's variable, but arrays are still inherently inflexible because of their fixed size. The `zero` function will not accept a pointer to a `[16]byte` variable, for example, nor is there any way to add or remove array elements. For those reasons, other than special cases like SHA256's fix-sized hash, arrays are seldom used as functions parameters; instead, we use slices.


### Slices

Slices represent variable-length sequences whose values all have the same type. A slice type is written `[]T`, where the elements have type `T`; it looks like an array type without a size.

Arrays and slices are intimately connected. A slice is a lightweight data structure that gives access to a subsequence (or perhaps all) of the elements of an array, which is known as the slice's _underlying array_. A slice has three components: a pointer, a length, and a capacity. The pointer points to the first element of the array that is reachable through the slice, which is not necessarily the array's first element. The length is the number of slice elements; it can't exceed the capacity, which is usually the number of elements between the start of the slice and the end of the underlying array. The built-in function s `len` and `cap` return those values.

Multiple slices can share the same underlying array and may refer to overlapping part of that array.

The _slice operator_ `s[i:j]`, where `0 <= i <= j <= cap(s)`, creates a new slice that refers to elements `i` through `j-1` of the sequence `s`, which may be an array variable, a pointer to an array, or another slice.

Slicing beyond `cap(s)` causes a panic, but slicing beyond `len(s)` extends the slice, so the result may be longer than the original.

Since a slice contains a pointer to an element of an array, passing a slice to a function permits the function to modify the underlying array elements. In other words, copying a slice creates an _alias_ for the underlying array. The function `reverse` reverses the elements of an `[]int` slice in place, and it may be applied to slices of any length:

    func reverse(s []int) {
        for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
            s[i], s[j] = s[j], s[i]
        }
    }

Here we reverse the whole array `a`:

    a := [...]int{0, 1, 2, 3, 4, 5}
    reverse(a[:])
    fmt.Println(a) // "[5 4 3 2 1]"

A _slice literal_ looks like an array literal, a sequence of values separated by comma and surrounded by braces, but the size is not given. This implicitly creates an array variable of the right size and yields a slice that points to it. As with array literals, slice literals may specify the values in order, or give their indices explicitly, or use a mix of the two styles.

Unlike arrays, slices are not comparable, so we cannot use `==` to test whether two slices contain the same elements. The standard library provides the highly optimized `bytes.Equal` function for comparing two slices of bytes (`[]byte`), but for other types of slice, we must do the comparison ourselves.

The only legal slice comparison is against `nil`. The zero value of a slice type is `nil`. A nil slice has no underlying array. The nil slice has length and capacity zero, but there are also non-nil slices of length and capacity zero, such as `[]int{}` or `make([]int, 3)[3:]`. As with any type that can have `nil` values, the nil value of a particular slice type can be written using a conversion expression such as `[]int(nil)`.

    var s []int     // len(s) == 0, s == nil
    s = nil         // len(s) == 0, s == nil
    s = []int(nil)  // len(s) == 0, s == nil
    s = []int{}     // len(s) == 0, s != nil

So, if you need to test whether a slice is empty, use `len(s) == 0`, not `s == nil`. Other than comparing equal to `nil`, a nil slice behaves like any other zero-length slice; `reverse(nil)` is perfectly safe, for example. Unless clearly documented to the contrary, Go functions should treat all zero-length slices the same way, whether nil or non-nil.

The built-in function `make` creates a slice of a specified element type, length, and capacity. The capacity argument may be omitted, in which case the capacity equals the length.

    make([]T, len)
    make([]T, len, cap) // same as make([]T, cap)[:len]

Under the hood, `make` creates an unnamed array variable and returns a slice of it; the array is accessible only through the returned slice. In the first form, the slice is a view of the entire array. In the second, the slice is a view of only the array's first `len` elements, but its capacity includes the entire array. The additional elements are set aside for future growth.

### The `append` function

The built-in `append` function appends items to slices. The `append` function is crucial to understand how slices work, so let's take a look at what's going on. Here's a version of called `appendInt` that is specialized for `[]int` slices:

    func appendInt([]int x, y int) []int) {
        var z int[]
        zlen := len(x) + 1
        if zlen <= cap(x) {
            z = x[:zlen]
        } else {
            // There is insufficient space. Allocate a new array.
            // Grow by doubling, for amortized linear complexity.
            zcap := zlen
            if zcap < 2 * len(x) {
                zcap = 2 * len(x)
            }
            z = make([]int, zlen, zcap)
            copy(z, x)
        }
        z[len(x)] = y
        return z
    }

The built-in function `copy`, which copies elements from one slice to another of the same type. The slices may refer to the same underlying array; they may even overlap. `copy` return the number of elements actually copied, which is the smaller of the two slice lengths, so there is no danger of running off the end or overwriting something out of range.

The built-in `append` function may use a more sophisticated growth strategy than `appendInt`'s simplistic one. Usually we don't know whether a given call to `append` will cause a reallocation, so we can't assume the original slice refers to the same array as the resulting slice, nor that it refers to a different one. Similarly, we must assume that operations on elements of the old slice will (or will not) be reflected in the new slice. As a result, it's usual to assign the result of a call to `append` to the same slice variable whose value we passed to `append`:

    runes = append(runes, r)

Updating the slice variable is required not just when calling `append`, but for any function that may change the length or capacity of a slice or make it refer to a different underlying array. To use slices correctly, it's important to bear in mind that although the elements of the underlying array are indirect, the slice's pointer, length, and capacity are not. To update them requires an assignment like the one above. In this respect, slices are not "pure" reference types but resemble an aggregate type such as this struct:

    type IntSlice struct {
        ptr *int
        len, cap int
    }

Our `appendInt` function adds a single element to a slice, but the built-in `append` lets us add more that one new element, or even a whole slice of them.

    var x []int
    x = append(x, 1)
    x = append(x, 2, 3)
    x = append(x, 4, 5, 6)
    x = append(x, x...) // appends the slice x
    fmt.Println(x) // "[1 2 3 4 5 6 1 2 3 4 5 6]"

With the small modification shown below, we can match the behavior of the built-in `append`. The ellipsis `...` in the declaration of `appendInt` makes the function _variadic_: it accepts any number of final arguments. The corresponding ellipsis in the call above shows how to supply a list of arguments from a slice.

    func appendInt([]int, y ...int) []int {
        var z int[]
        zlen := len(x) + len(y)
        // expands z to at least zlen
    }

### Maps

The hash table is one of the most ingenious and versatile of all data structures. It is an unordered collection of key/pairs in which all the keys are distinct, an the value associated with a given key can be retrieved, updated or removed using a constant number of key comparisons on the average, no matter how large the hash table.

In Go, a _map_ is a reference to a hash table, and a map type is written `map[K]V`, where `K` and `V` are the types of its keys and values. All of the keys in a given map are of the same type, and all of the values are of the same type, but the keys need not to be of the same type as the values. The key type `K` must be comparable with `==`, so that the map can test whether a given key is equal to one already within it.

The built-in function `make` can be used to create a map:

    ages := make(map[string]int) // mapping from strings to ints

We can also use a _map literal_ to create a new map populated with some initial key/value pairs:

    ages := map[string]int{
        "alice":    31,
        "charlie":  34,
    }

So the expression for a new empty map is `map[string]int{}`.

Map elements are accessed through the usual subscript notation:

    ages["alice"] = 32

and removed with the built-in function `delete`:

    delete(ages, "alice")

All these operations are safe even if the element isn't in the map; a map lookup using a key that isn't present return the zero value for its type, so, for instance, the following works even when "`bob`" is not yet a key in the map because the value of `ages["bob"]` will be `0`:

    ages["bob"] = ages["bob"] + 1 // happy birthday!

But a map element is not a variable, and we cannot take its address:

    _ = &ages["bob"] // compile error: cannot take address of map element

One reason that we can't take the address of a map element is that growing a map might cause rehashing of existing elements into new storage locations, thus potentially invalidating the address.

To enumerate all the key/values pairs in the map, we used a `range`-based `for` loop similar to those we saw for slices:

    for name, age := range ages {
        fmt.Printf("%s\t%d\n", name, age)
    }

The order of map iteration is unspecified, and different implementations might use a different hash function, leading to different ordering. In practice, the order is random, varying from on execution to the next. This is intentional; make the sequence vary help force programs to be robust across implementations. To enumerate the key/value pairs in order, we must sort the key explicitly, for instance, using the `Strings` function from the `sort` package if the keys are string. This is a common pattern:

    import "sort"

    var names string[]
    for name := range ages {
        names = append(names, name)
    }
    sort.Strings(names)
    for _, name := range names {
        fmt.Pringf("%s\t%d\n", name, ages[name])
    }

Since we know the final size of `names` from the outset, it is more efficient to allocate an array of the required size up front:

    names := make([]string, 0, len(ages))

The zero value for a map type is `nil`, that is, a reference to no hash table at all.

Most operations on maps, including lookup, `delete`, `len` and `range` loops, are safe to perform on a nil map reference, since it behaves like an empty map. But storing to a nil map causes a panic:

    ages["carol"] = 24 // panic: assignment to entry in nil map

You must allocate the map before you can store into it.

The second return value of subscripting a map is a boolean that reports whether the element was present:

    if age, ok := ages["bob"]; if !ok { /* ... */ }

As with slices, maps cannot be compared to each other; the only legal comparison is with `nil`.

Go does not provide a `set` type, but since the keys of the map are distinct, a map can serve this purpose.

The value type of a map can itself be a composite type, such as a map or slice.